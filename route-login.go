package main

import (
	"time"
	"net/http"

	"github.com/ivanrave/go-jwt-auth/dbauth"
)

var maxRetry int = 3

var (
	errLgnRequired = apiError{
		Code: "LgnRequired",
		Description: "Lgn format: min 3 symbols",
	}
	errVcodeRequired = apiError{
		Code: "VcodeRequired",
		Description: "Verification code format: min 3 symbols",
	}
	errVcodeNotExists = apiError{
		Code: "VcodeNotExists",
		Description: "A verification code is not found for this login: probably it expired. Please generate a new verification code",
	}
	errCodeMismatch = apiError{
		Code: "CodeMismatch",
		Description: "The verification code is not correct",
	}
	errCodeMaxRetry = apiError{
		Code: "CodeMaxRetry",
		Description: "Max number of retries: a code is deleted. Please generate a new verification code",
	}
)

func checkRetry(lgn string, retryPrev int) error {
	if retryPrev > maxRetry {
		errDel := dbauth.DelKey(lgn)
		if errDel != nil { return errDel }
		
		return errCodeMaxRetry
	}

	return nil
}

func routeLogin (w http.ResponseWriter, r *http.Request) error {
	lgn := r.FormValue("lgn")
	
	if len(lgn) < 3 { return errLgnRequired }

	vcode := r.FormValue("vcode")

	if len(vcode) < 3 { return errVcodeRequired	}

	// previous verification code, generated by a user on a prev step
	vcodePrev, retryPrev, err := dbauth.GetVcode(lgn)

	if err != nil {
		if err == dbauth.ErrLgnNotFound {
			// return err
			return errVcodeNotExists
		}
		
		return err
	}
	
	if len(vcodePrev) < 3 {	return errVcodeNotExists }

	// check before a try and after
	// possible max retry overhead for concurrent requests
	err = checkRetry(lgn, retryPrev)
	if err != nil { return err }
	
	
	if vcode != vcodePrev {		
		// add retry if possible
		// if 2 > 3 else Add
		// if 3 > 3 else Add
		// if 4 > 3 - delete
		// usually a max-retried key deletes here
		err = checkRetry(lgn, retryPrev + 1)
		if err != nil { return err }

		errRetry := dbauth.AddRetry(lgn)
		if errRetry != nil { return errRetry }

		return errCodeMismatch
	}

	// then: Generate JWT token
	// send to the user as Cookie or smth else
	expiration := time.Now().Add(24 * time.Hour)
	
	jwt, err := calcJWT(lgn, expiration)

	if err != nil {	return err }

	//time.Now().Add(time.Second * time.Duration(seconds))

	// *Cookie
	cookie := http.Cookie{
		Name: "authtoken",
		Value: jwt,
		Expires: expiration,
		//		Secure: true,
	}
	
	http.SetCookie(w, &cookie)
	
	//fmt.Fprintf(w, jwt)
	http.Redirect(w, r, "./", 302)
	return nil
}
